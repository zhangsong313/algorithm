package com.zs.shuati.class05;

/**
 * 题目：
 *
 * 1 已知一棵搜索二叉树上没有重复值的节点，现在有一个数组arr，
 * 是这棵搜索二叉树先序遍历的结果，请根据arr生成整棵树并返回头节点
 * https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/
 * 解：搜索二叉树决定了第一位置为头节点，比头节点小的范围为左树，比头节点大的范围为右树。
 * 单调栈：需要找到指定位置数据右边比当前位置大的第一个位置。可以使用单调栈优化。
 *
 * 2 如果一个节点X，它左树结构和右树结构完全一样，那么我们说以X为头的树是相等树，
 * 给定一棵二叉树的头节点head，返回head整棵树上有多少棵相等子树
 * 解：二叉树的递归套路。使用哈希值做两个树是否相等的比较。
 *
 * 3 编辑距离问题
 * 解：动态规划：样本对应模型
 *
 * 4 给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？比如 s1 = "abcde"，s2 = "axbc"，s2删掉'x'即可，返回1
 * 解：动态规划：样本对应模型
 */
public class T {
}
