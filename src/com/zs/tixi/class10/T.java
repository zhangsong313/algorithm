package com.zs.tixi.class10;

import java.util.Arrays;

/**
 * 1. 排序算法总结：
 *              | 时间复杂度     | 空间复杂度 | 稳定性   |
 *      选择排序 | O(N^2)       | O(1)      | 无     |
 *      冒泡排序 | O(N^2)       | O(1)      | 有     |
 *      插入排序 | O(N^2)       | O(1)      | 有     |
 *      归并排序 | O(N*logN)    | O(N)      | 有     |
 *      快速排序 | O(N*logN)    | O(logN)   | 无     |
 *      堆排序  | O(N*logN)    | O(1)      | 无     |
 *      ======================================
 *      计数排序 | O(N)         | O(M)      | 有     |
 *      基数排序 | O(N)         | O(N)      | 有     |
 *
 * 2. 各种排序算法的选择
 *      1) 不基于比较的排序，对样本有要求，不易改写。
 *      2） 基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
 *      3） 基于比较的排序，时间复杂度的极限时O（N*logN）
 *      4) 时间复杂度O(N*logN)，额外空间复杂度低于O(N)，且稳定的排序是不存在的。
 *      5） 为了绝对的速度选快排，为了空间选堆，为了稳定性选归并。
 * 3.
 *      常见的坑：
 *      1） 归并排序的额外空间复杂度可以变成O(1)， ”归并排序 内部缓存法“， 但是将变得不稳定。
 *          （不如直接使用堆排序）
 *      2） ”原地归并排序“是垃圾贴，会让时间复杂度变为O（N*2）
 *          （不如使用冒泡或插入）
 *      3) 快速排序稳定性改进，”01 stable sort“， 但是会对样本数据要求更多。
 *          （同样对样布数据有要求且稳定的排序有计数排序和基数排序，时间复杂度还更好）
 *      4）在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始相对的次序不变，所有偶数之间原始相对次序不变，
 *          时间复杂度要求O(N)，额外空间复杂度做到O(1)。
 *          （如果可以实现按照不同条件把数组分成两部分，时间O(N)，空间O(1)，且稳定的方法，快速排序的partition也不会不稳定了。）
 * 4. 工程上对排序算法的改进
 *      1）稳定性的考虑：基础类型使用不稳定的快排，非基础类型使用稳定的归并排序
 *      2）充分利用O(N*logN)和O(N^2)排序的各自优势：数据量小的排序使用常数时间更小的排序，而不是时间复杂度更低的排序。
 *          需要进行大量实验来确定在什么数据量级上选择什么样的排序。
 * 5. 链表问题：
 *      1）对于笔试，不用在乎空间复杂度，一切为了时间复杂度，尽可能使用容器方案加快答题速度。
 *      2）对于面试，时间复杂度依然排在第一位，但是一定要找到空间最省的方法。
 * 6. 常见解题技巧：
 *      1）使用容器（哈希表，数组等）
 *      2）快慢指针
 * 7. 快慢指针练习
 *      1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点。
 *          // 定义快慢指针fast和slow指向head
 *         // 快指针每次走两步，慢指针每次走一步。快慢指针的位置组合规律为[1, 1], [2, 3], [3, 5], [4, 7]
 *         // 可以看出规律：快指针每次走在奇数位置上，且慢指针位置为快指针结尾的链表中点。
 *         // 循环：如果fast.next==null，说明链表长度为奇数。
 *         //      如果fast.next.next==null，说明链表长度为偶数。
 *         //      根据题目要求,不论长度奇数还是偶数，都返回slow
 *         //      fast移动两步，slow移动一步
 *      2）输入链表头节点，奇数长度返回中点，偶数返回下中点。
 *          // 循环：如果fast.next==null，说明链表长度为奇数。
 *         //      如果fast.next.next==null，说明链表长度为偶数。
 *         //      根据题目要求,奇数返回slow，偶数返回slow.next
 *         //      fast移动两步，slow移动一步
 *      3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个。
 *          // 循环：如果fast.next==null，说明链表长度为奇数。
 *         //      如果fast.next.next==null，说明链表长度为偶数。
 *         //      根据题目要求,奇数或偶数都返回slow的前一个节点
 *         //      fast移动两步，slow移动一步
 *      4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个。
 *          // 循环：如果fast.next==null，说明链表长度为奇数。
 *         //      如果fast.next.next==null，说明链表长度为偶数。
 *         //      根据题目要求,奇数返回slow的前一个节点，偶数返回slow
 *         //      fast移动两步，slow移动一步
 * 8. 常见面试题：
 *      1）给定一个单链表头节点，判断该链表是否为回文结构。
 *          哈希表解决很简单。（笔试用）
 *          改变原链表方式需要注意边界（面试用）
 *          思路：
 *              <1> 全部节点压栈比较，空间复杂度：O(N)
 *                  // 将链表节点入栈。
 *                  // 从head开始依次和栈中弹出的节点比较val大小。如果出现不相等的，直接返回false
 *              <2> 后半部分压栈比较。空间复杂度:O(N)
 *                  // 找到链表中点mid：奇数为中点，偶数为下中点。
 *                  // 将中点开始的节点压栈。
 *                  // 从head开始，依次与栈弹出的节点比较，直到栈为空。遇到val不相等的情况返回false。
 *              <3> 后半部分指针反转，头尾相向而行比较
 *                  // 找到链表中点mid:奇数找到中点，偶数找到下中点
 *                  // 从mid开始反转链表直到结束。（mid指向mid，保证不论奇偶头尾指针相向而行都可以相遇）
 *                  // 当head!=tail时，比较head.val和tail.val。如果遇到不相等的情况，设置答案为false，跳出循环。
 *                  // 最后记得将链表后半部分恢复，然后返回答案。
 *      2）将单向链表按某值划分成左边小中间相等，右边大的形式。
 *          <1>将链表放入数组，对数组做partition（笔试用）
 *              // 将链表节点依次放入list中。
 *              // 定义小于区域指针和大于区域指针。根据pivot进行分区。
 *              // 将list中的节点串起成链表。注意最后一个节点的next需要设置为null。
 *              // 返回链表头节点
 *          <2>分成小，中，大三部分，再把各个部分串起来。（面试用）
 *              // 定义smallHead, smallTail, equalsHead, equalsTail, bigHead, bigTail用来表示小于区域链表，等于区域链表，大于区域链表。
 *              // 通过与pivot相比找到对应区域的尾指针tail，tail.next指向当前节点。tail更新为当前节点。
 *              // 将三条链表串起来，这步是难点。(定义head和tail。先合并小于区域，再合并等于区域，再合并大于区域，最后设置tail.next为null)
 *      3）一种特殊的单链表节点类描述如下：
 *          题目：class Node{ int val; Node next; Node rand;}
 *          rand指针是单链表节点中新增的指针，可能指向链表中的任意节点，也可能指向Null。
 *          给定一个由Node节点组成的无环单链表的头节点Head，请完成一个函数实现这个链表的复制，并返回复制新链表的头节点。
 *          要求：时间复杂度O(N)，额外空间复杂度O(1)
 *          思路：
 *          <1> 使用容器维护与克隆节点关系，额外空间复杂度O(N)
 *              // 定义map，每个node为key，根据node克隆出的新节点为val放入map。
 *              // 遍历链表，根据每个node的next和rand指针为对应map中的克隆节点设置next和rand指针。
 *          <2> 使用next指针维护与克隆节点关系，额外空间复杂度O(1)
 *              // 在每个node后插入node的克隆节点。（不需要map的情况下，记录了node和克隆节点的关系。）
 *              // 根据node的rand指针设置克隆节点的rand指针。
 *              // 将node和克隆节点分开为两条单独的链表（设置next指针）
 */
public class T {
    public static void main(String[] args) {
        Arrays.sort(new int[0]);
    }
}
