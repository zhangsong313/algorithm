package com.zs.tixi.class8;

/*
 * 3. 改写堆练习题：给消费最高的客户发奖。要求每次消费发生后,实时展示获奖人和消费信息。
 *      给定一个整型数组int[] arr，和一个布尔型数组boolean[] op。两个数组一定等长，arr[i]表示客户编号, op[i]表示客户发生了一次操作
 *      arr = [3, 3, 1, 2, 1, 2, 5, ...]
 *      op = [T, T, T, T, F, T, F, ...]
 *      依次表示：3用户购买了一件商品，3用户购买了一件商品，1用户购买了一件商品，2用户购买了一件商品， 1用户退货了一件商品， 2用户购买了一件商品， 5用户退货了一件商品...
 *      得奖的规则：
 *          1) 用户购买0件商品时，发生的退货事件无效。
 *          2) 购买事件发生一次，用户购买商品数加1，反之，减一。
 *          3) 获奖池大小为K，如果消费人数不够K，就按不够的情况输出。
 *          4) 得奖系统分为得奖区和候选区，用户只要购买数>0，必在这两个区域的一个。
 *          5) 购买数最大的前K名用户进入得奖区。如果得奖区没有满，新购买用户直接进入得奖区
 *          6) 得奖区已满，购买数不足以进入得奖区的用户，进入候选区
 *          7) 候选区购买数最多的用户，有资格评选是否进入得奖区:
 *              该用户大于得奖区购买最少的用户，替换该用户进入得奖区。
 *              得奖区购买最少的用户有多个，替换最早进入得奖区的用户
 *              候选区购买最多的用户有多个，机会优先给最早进入候选区的用户
 *          8) 用户进入候选区或得奖区时，需要记录当前购买时间，只要一直保持在当前区域，购买时间不变。否则购买时间删除。
 *          9) 如果用户购买数变为0，将用户消费记录删除（不论在候选区还是得奖区）。下次用户再次购买，视为新用户.
 *      要求，根据系统给定的arr数组，op数组和得奖区大小K，遍历arr，每i位置输出当前得奖名单，要求每次输出时间复杂度O(1)（实际需求是要求实时展示得奖区的情况）
 */
public class Code02_EveryStepShowBoss {
    /**
     * 创建候选区的加强堆candHeap。比较器逻辑：消费最高在前，消费最高的取最先消费的在前。
     * 创建得奖区的加强堆winHeap。比较逻辑：消费最低的在前，消费最低的取最先消费的在前。
     * 创建map<id, Customer>记录对应id的客户消费情况。
     * 创建List<List<Customer>> everStepWinList作为每一步得奖名单列表的集合
     * 循环事件数组arr：
     *      查询map中是否存在当前客户，如果不存在：
     *          消费为退货：无效消费，直接进入下次循环。
     *          消费为买货：将当前客户初始化后放入候选区，在map中登记客户
     *      如果存在，map中取出信息更新客户的消费情况，
     *          如果更新后消费为0，将客户从map中删除，分别判断得奖区和候选区中是否存在该客户并删除。
     *          如果更新后消费不为0，分别判断候选区和得奖区是否包含客户并更新加强堆。
     *      如果候选区为空：进入下次循环。
     *      从得奖区弹出哪些消费小于候选区堆顶的客户，这些客户更新消费时间后进入候选区。
     *      如果得奖区size小于K，从候选区弹出客户直到得奖区size等于K。
     *      从winHeap获取所有元素组成新列表加入everStepWinList。（此处应该不能直接存入对象，而是重新创建Customer，否则历史得奖信息会发生变化）
     */
    public static void everyStepShowBoss(){}
}
