package com.zs.tixi.class8;

/*
 * 3. 改写堆练习题：给消费最高的客户发奖。要求每次消费发生后,实时展示获奖人和消费信息。
 *      给定一个整型数组int[] arr，和一个布尔型数组boolean[] op。两个数组一定等长，arr[i]表示客户编号, op[i]表示客户发生了一次操作
 *      arr = [3, 3, 1, 2, 1, 2, 5, ...]
 *      op = [T, T, T, T, F, T, F, ...]
 *      依次表示：3用户购买了一件商品，3用户购买了一件商品，1用户购买了一件商品，2用户购买了一件商品， 1用户退货了一件商品， 2用户购买了一件商品， 5用户退货了一件商品...
 *      得奖的规则：
 *          1) 用户购买0件商品时，发生的退货事件无效。
 *          2) 购买事件发生一次，用户购买商品数加1，反之，减一。
 *          3) 获奖池大小为K，如果消费人数不够K，就按不够的情况输出。
 *          4) 得奖系统分为得奖区和候选区，用户只要购买数>0，必在这两个区域的一个。
 *          5) 购买数最大的前K名用户进入得奖区。如果得奖区没有满，新购买用户直接进入得奖区
 *          6) 得奖区已满，购买数不足以进入得奖区的用户，进入候选区
 *          7) 候选区购买数最多的用户，有资格评选是否进入得奖区:
 *              该用户大于得奖区购买最少的用户，替换该用户进入得奖区。
 *              得奖区购买最少的用户有多个，替换最早进入得奖区的用户
 *              候选区购买最多的用户有多个，机会优先给最早进入候选区的用户
 *          8) 用户进入候选区或得奖区时，需要记录当前购买时间，只要一直保持在当前区域，购买时间不变。否则购买时间删除。
 *          9) 如果用户购买数变为0，将用户消费记录删除（不论在候选区还是得奖区）。下次用户再次购买，视为新用户.
 *      要求，根据系统给定的arr数组，op数组和得奖区大小K，遍历arr，每i位置输出当前得奖名单，要求每次输出时间复杂度O(1)（实际需求是要求实时展示得奖区的情况）
 */
public class Code02_EveryStepShowBoss {
}
