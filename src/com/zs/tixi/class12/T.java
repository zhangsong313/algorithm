package com.zs.tixi.class12;

/**
 * 1. 实现二叉树的按层遍历。
 *      1）其实就是宽度优先遍历，使用队列。
 * 2.
 *      二叉树可以通过先序，后序或按层遍历实现序列化和反序列化。请依次实现。
 * 3.    Leetcode 431.Encode N-ary Tree to Binary Tree
 * 测试链接：https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree
 *      请将一颗多叉树用二叉树表示，并可以还原回多叉树。
 * 4. 如何设计一个打印整颗树的打印函数。（将树结构打印成类似图像的形式）
 *
 * 5. 求二叉树最宽的层有多找个节点。
 *
 * 6. 二叉树结构如下定义：
 *      Class Node {
 *          V value;
 *          Node left;
 *          Node right;
 *          Node parent;
 *      }
 *      给你二叉树中的某个节点，返回后继节点。
 *      后继节点：中序遍历中当前节点的下一节点。
 *
 * 7. 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。
 *      此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折两次，
 *      压出折痕后展开，此时有三条折痕，从上到下依次是凹折痕，凹折痕，凸折痕。
 *      给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。
 *      例如：N=1时，打印 “凹” . N=2时，打印 “凹”， “凹”， “凸”。
 */
public class T {

    /*
         1. 实现二叉树的按层遍历。
             其实就是宽度优先遍历，使用队列。
             思路：
                将头节点放入队列。
                循环：直到队列为空。
                    每次从队列中取出节点，打印节点值。
                    如果左节点不为空，左节点加入队列。
                    如果右节点不为空，右节点加入队列。
             注：如果需要区分不同层的节点。需要记录当前层的最后一个节点以及下一层的最后一个节点。

         2. 二叉树可以通过先序，后序或按层遍历实现序列化和反序列化。请依次实现。
            （1）先序序列化
            // 二叉树带着队列queue做先序遍历。
            // 如果当前节点为null，将null加入queue。
            // 当前节点不为null，将当前节点值加入queue，然后递归处理子节点。
            （2）先序反序列化
            // 从队列serialQueue中取出节点，
            // 如果节点为空，返回null。
            // 节点不为空，用当前值构建节点，作为头节点。
            // 递归调用构建left子节点。
            // 递归调用构建right子节点。
            （3）后序序列化
            // 带着队列queue做后序遍历。
            // 如果当前节点为null，将null加入queue。
            // 当前节点不为null，递归处理左子节点。递归处理右子节点，当前节点加入队列queue。
            （4）后序反序列化
            // 使用栈stack将队列中的节点全部加入。
            // 带着栈stack做先序遍历。和先序反序列化的流程一样。
            （5）按层序列化
            // 带着queue做按层遍历。
            // 如果当前节点为null，将null加入queue。
            // 当前节点不为空，将当前节点值加入queue。
            （6）按层反序列化
            // 从序列化的队列serialQueue中依次弹出节点值。
            // 定义用来按层构建二叉树的队列queue。
            // 从serialQueue中取出一个节点作为第一层节点放入queue中，然后采用按层遍历的方式处理queue。
            // 在queue按层构建二叉树的过程中，从serialQueue中取出需要的节点作为子节点。直到queue为空。

        3. 请将一颗多叉树用二叉树表示，并可以还原回多叉树
            测试链接（会员题目）：https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree
            思路：
                多叉树的子节点列表children转换为二叉树节点的左树的右边界。
        4. 求二叉树最宽的层有多找个节点。
            思路：二叉树的按层遍历，根据最后的节点分层，统计每层节点值。
        5. 二叉树的后继节点
            题目：
                二叉树结构如下定义：
                 Class Node {
                     V value;
                     Node left;
                     Node right;
                     Node parent;
                 }
                 给你二叉树中的某个节点，返回后继节点。
                 后继节点：中序遍历中当前节点的下一节点。
            思路：
                // 当前节点为null，直接返回null（无法根据空节点查找）
                // 中序遍历的顺序为：左子树，头节点，右子树。
                // 情况一：将node看作头节点，如果右子树不为空，后继节点为右子树的最左节点。
                // 情况二：如果父节点不为空，且node为左子树，后继节点为父节点。
                // 情况三：如果父节点不为空，且node为右子树，将父节点整体作为左子树考察情况二：
                //          考虑父节点的父节点不为空且父节点为左子树的情况，直到父节点为空。
         6. 纸条折叠问题：
            题目：
                 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。
                 此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折两次，
                 压出折痕后展开，此时有三条折痕，从上到下依次是凹折痕，凹折痕，凸折痕。
                 给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。
                 例如：N=1时，打印 “凹” . N=2时，打印 “凹”， “凹”， “凸”。
            思路：
                纸条折痕实际上就是一颗以第一次的中间折痕为头节点的二叉树。
                “凹”和“凸”可以看作二叉树节点的两种值。
                每个节点的左节点是“凹”，右节点是“凸”。
                只要指定了折叠的次数，也就指定了二叉树的层数。执行一次先序遍历打印节点值就可以了。
          7. 是否完全二叉树
            完全二叉树：二叉树每层从左到右，如果遇到空节点，则该层后序节点一定都为空，且该层为二叉树最后一层。
            思路：
                // 二叉树的按层遍历。
                // 遇到左子树为空，右子树不为空，返回false。
                // 如果之前已经有子节点为空的情况。再遇到子节点不为空，返回false。

     */
}
