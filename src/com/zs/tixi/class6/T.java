package com.zs.tixi.class6;

import com.zs.xiaobai.common.MyCompValue;

/**
 * 1.给定一个数组arr,两个整数lower和upper,返回arr中有多少个子数组累加在[lower,upper]范围上.
 * 2.荷兰国旗问题.给定一个数组arr和arr中的一个数X,返回arr,使得小于X的放左边,等于X的放中间,大于X的放右边.
 * 3.快速排序1.0版本,荷兰国旗问题中,X为初始最右边的数,小于等于放左边,以X结尾,大于X的放右边.
 * 4.快速排序2.0版本,X为初始最右边的数,小于X的放左边,等于X的放中间,大于X的放右边
 * 5.随机快速排序.(真正概念上的快速排序),随机将arr中的一个数与最右边互换.X为初始最右边的数,小于X的放左边,等于X的放中间,大于X的放右边
 * 6.快排3.0非递归,使用Stack记录等于区的位置,将左右两边的任务下压栈等待循环执行.
 */
public class T {
    /*
        笔记整理：
            累加和在指定范围内的子数组个数：
                首先将数组arr转换为前缀和数组sum
                对于以终点j位置结尾的子数组，符合条件的起点i位置，要求sum[j]-sum[i]>=lower，且sum[j]-sum[i]<=upper。
                转换后可得sum[i]<=sum[j]-lower，且sum[i]>=sum[j]-upper。
                但因为sum[i]是无序的，所以j位置左侧符合条件的i位置必定是离散的，需要每次遍历0-j范围。解题的时间复杂度为O(N^2)
                在归并排序中，对于右部分每个位置作为子数组结尾的j位置，左边可以得到一个符合条件的i位置的连续范围（左部分有序）。
                又因为右部分有序，所以sum[j+1]大于sum[j]，所以j结尾时候的i范围指针可以不回退继续向右移动，得到j+1结尾时的i范围指针。
                解题的时间复杂度为O(N*logN)
                注：这道题用归并排序解题的思路很难想到，核心问题在于j位置左侧有多少个i位置的值在符合条件的范围内无法快速得到。
                后面的有序表章节在学习改写有序表后，改写出一个可以logN时间内得到表内在指定范围的值有多少的有序表结构。
                用来解决该问题会更加容易理解。
            快排1.0:
                // 核心：将数组按最右侧值分区，得到分界点i，i的左侧小于等于i位置的值，i的右侧大于i位置的值。
                // 递归对i左侧位置分区，递归对i右侧位置分区，直到分区长度为0.
                // 定义process函数做递归处理，base case为L>=R
                // 定义分区函数，将数组指定范围按照最右侧值分为左右两区域。
            快排2.0:
                // 核心：将数组按最右侧值分区，得到等于区域，等于区域的左侧小于最右值，等于区域的右侧大于最右值。
                // 递归对等于区域左侧分区，递归对等于区域右侧分区，直到分区长度为0.
                // 定义process函数做递归处理，base case为L>=R
                // 定义分区函数，将数组指定范围按照最右侧值分为左中右两区域。将中间等于区域的边界值返回.
            随机快排：真正意义的快排
                快排2.0当最右侧值始终为最大值或最小值这种极端数据状况下，时间复杂度为O(N^2)。
                因此每次分区前将最右侧值与一个随机位置互换，保证在各种数据状况下。各种随机结果的平均排序的时间复杂度保持在O(N*logN)
                // 核心：将最右侧值与一个随机位置互换。然后数组按最右侧值分区，得到等于区域，等于区域的左侧小于最右值，等于区域的右侧大于最右值。
                // 递归对等于区域左侧分区，递归对等于区域右侧分区，直到分区长度为0.
                // 定义process函数做递归处理，base case为L>=R
                // 定义分区函数，将数组指定范围按照最右侧值分为左中右两区域。将中间等于区域的边界值返回.
            非递归快排：
            双链表的随机快排：

     */

    public static void main(String[] args) {
        MyCompValue.checkSort(1000, 99, 99, Code02_PartitionAndQuickSort::quickSort1_0);
        MyCompValue.checkSort(1000, 99, 99, Code02_PartitionAndQuickSort::quickSort2_0);
        MyCompValue.checkSort(1000, 99, 99, Code02_PartitionAndQuickSort::quickSort);
    }
}
