package com.zs.tixi.class28;

/**
 * KMP算法
 *      假设字符串str长度为N,字符串match长度为M,M<=N
 *      想确定str中是否有某个子串是等于match的.
 *      时间复杂度O(N)
 *
 * KMP算法核心
 *      1)如何理解next数组
 *          给定一个字符串match="aabaa"
 *          next数组与match长度相等
 *          next数组的i位置值表示0..i-1范围内前缀和后缀字符串完全相同的前后缀长度。（不能是0..i-1全部长度）
 *          例如：
 *          0位置：前面没有字符，值为-1
 *          1位置：前面只有一个字符，又不能是整体长度，值为0.
 *          2位置：前面字符为"aa",最长相等的前后缀长度为1，值为1
 *          3位置: 前面字符为"aab",值为0
 *          4位置：前面字符为"aaba",值为1
 *          5位置: 没有5位置。
 *      2)如何利用next数组加速匹配过程,优化时的两个实质.
 *          现在来到str的i位置,从此位置开始尝试匹配match.
 *          一路匹配都相等（相等字符用.表示），直到X字符遇到了match的Y字符，发现不相等了。
 *          [i....].....[.....]X
 *          [0....].....[.....]Y
 *          假设next数组中Y位置的值为5
 *          所以match字符串Y位置之前的前缀和后缀相等的最大长度为5，由于前面一路都相等，因此str字符串也有相同的前后缀情况.
 *
 *          ① 将match前缀向右移动到相等后缀位置，X与相等前缀的下一个字符Z尝试进行匹配。
 *          [i....].....[.....]X
 *                       j
 *                      [0....]Z
 *          这时已经在进行str的j位置尝试匹配match了。因为相等的前缀和后缀，所以不用从j位置开始匹配，直接从X位置开始尝试。
 *
 *          ②为什么不尝试i..j位置之间的这些位置匹配match的可能性？
 *          假设i..j之间有某一个位置k，从此位置开始可以匹配match。
 *          i...[...........]X
 *              k
 *              [0..........]....Y
 *          0...[...........]Y
 *          那么str从k开始的后缀和match0开始相同长度的前缀必定相等。
 *          又因为i一路匹配到X之前，这些字符都相等
 *          所以match的0到相同长度的前缀 与 match相同长度的后缀必定相等，且此长度超过了5.
 *          这与next数组的最长前后缀匹配长度定义冲突
 *          因此i..j位置之间没有匹配出match的可能性。
 *      3)如何快速求解next数组
 * 题目一:
 *      给定两颗二叉树的头节点head1和head2
 *      想知道head1中是否有某个子树的结构和head2完全一样.
 *
 * 题目二:
 *      判断str1和str2是否是旋转字符串.
 *      旋转字符串指的是将字符串包含任意个字符的左部分移动到右边.
 *      例如123456和456123互为旋转串.
 */
public class T {
}
