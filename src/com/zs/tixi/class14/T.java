package com.zs.tixi.class14;

/**
 * 1.二叉树递归套路续：判断二叉树是否是完全二叉树。
 * 2.二叉树递归套路续：返回这颗二叉树中最大二叉搜索子树的头节点。
 * 3.二叉树递归套路续：给定二叉树的头节点head和另外两个节点a，b。返回a和b的最低公共祖先。
 * 4.二叉树递归套路续：
 *      派对的最大快乐值：
 *          员工信息定义如下：
 *              class Employee{
 *                  public int happy; // 这名员工可以带来的快乐值。
 *                  List<Employee> subordinates; // 这名员工有哪些直接下级。
 *              }
 *          公司的每个员工都符合Employee的描述。整个公司的人员结构可以看作是一颗标准的，没有环的多叉树。
 *          树的头节点是公司唯一的老板。除老板以外的每一个员工都有唯一的一个直接上级。叶节点是没有任何下级的基础员工（subordinates为空）
 *          除基层员工外，每个员工都有一个或多个直接下级。
 *
 *          这个公司现在要办party，你可以决定哪些员工来，哪些员工不来。规则：
 *          1）如果某个员工来了，那么这个员工的所有直接下级都不能来。
 *          2）排队的整体快乐值是所有到场员工快乐值的累加。
 *          3）你的目标是让派对的快乐值尽量大。
 *          给定一颗多叉树的头节点boss。请返回排队的最大快乐值。
 * 5. 贪心算法：
 *      1）最自然智慧的算法。
 *      2）用一种局部最功利的标准，总是做出在当前看来是最好的选择。
 *      3）难点在于证明局部最功利的标准可以得到全局最优解。
 *      4）对贪心算法的学习，主要以增加阅历和经验为主。
 *   贪心练习：
 *      给定一个由字符串组成的数组strs。
 *      必须把所有的字符串拼接起来，返回所有可能的拼接结果中，字典序最小的结果。
 *   贪心算法的标准求解过程：
 *      1）分析业务
 *      2）根据业务逻辑找到不同的贪心策略。
 *      3）对于能举出反例的策略直接跳过，不能举出反例的策略要证明有效性。
 *          这往往是特别困难的，要求数学能力很高且不具有同一的技巧性。
 *   贪心算法的解题套路：
 *      1）实现一个不依靠贪心策略的解法X，可以用最暴力的尝试。
 *      2）脑补出贪心策略A，贪心策略B，贪心策略C。。。
 *      3）用解法X和对数器，用实验的方式得知那个贪心策略正确。
 *      4）不要去纠结贪心策略的证明。
 */
public class T {
}
