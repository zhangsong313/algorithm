package com.zs.tixi.class17;

/**
 * 图：
 * 1）由点的集合和边的集合构成。
 * 2）虽然有有向图，无向图的概念，但无向图其实就可以看作双向的有向图。
 * 3）边上可能带有权值。
 *
 * 图结构的表达：
 * 1）邻接表法。
 *      用map表示图:{a:[b, c, d], b:[c, d, e]}
 *      其中,map的key表示起点,value数组表示从当前起点可以直到到达哪些点.
 * 2）邻接矩阵法
 *      图中有N个点,用一个N*N的矩阵表示哪些点是可以直接到达的,距离是多少.
 *        a  b c
 *      a 0  8 -1
 *      b -1 0  5
 *      c -1 -1 0
 *      上图表示a到b边长为8,b到c边长为5.除此以外没有其他边.
 * 3)除此之外还有众多的方式。
 *      [3, 1, 1, 1]
 *      表示下标位置到对应值位置有条路.
 *      0有到3的边,1有到1的边,2有到1的边,3有到1的边.
 *
 *      面试常见形式:
 *      [[3, 0, 7]
 *       [5, 1, 2]
 *       [6, 2, 7]]
 *       上图表示0到7有距离为3的边,1到2有距离为5的边,2到7有距离为6的边.
 *
 *       介绍一种左老师常用的图表达形式:
 *       Graph: // 图
 *          public HashMap<Integer, Node> nodes; // 图的所有节点 ,key为值,value为对应的节点对象.
 *          public HashSet<Edge> edges; // 图的所有边
 *       Node: // 点
 *          public int value; // 值
 * 	        public int in; // 入度,有多少条边指向该点.
 * 	        public int out; // 出度,从当前点有多少条边出去.
 * 	        public ArrayList<Node> nexts; // 临接点,当前点出发直接路径可以到哪些点.
 * 	        public ArrayList<Edge> edges; // 临接边,当前点出发有哪些边
 * 	     Edge: // 边
 * 	        public int weight; // 当前边的权重值
 * 	        public Node from; // 当前边从哪个点来
 * 	        public Node to; // 当前边指向哪个点
 *
 * 图的面试题如何搞定
 * 图的算法都不太难，只不过coding的代价比较高。
 * 1）先用自己最熟练的方式，实现图结构的表达。
 * 2）在自己熟悉的结构上，实现所有常用的图算法作为模板。
 * 3）把面试题提供的图结构转化为自己熟悉的图结构，再调用模板或改写即可。
 *
 * 图的宽度优先&深度优先遍历
 *      宽度优先遍历：
 *          1.利用队列实现
 *          2.从源节点开始依次按照宽度进队列，然后弹出。
 *          3.每弹出一个点，把该节点所有没有进过队列的邻接点放入队列。
 *          4.直到队列变空。
 *      深度优先遍历：
 *          1.利用栈实现。
 *          2.从源节点开始把节点放入栈，然后弹出。
 *          3.每弹出一个节点，把该节点下一个没有进入过栈的临界点放入栈。
 *          4.直到栈变空。
 *
 * 图的拓扑排序算法: 拓扑排序要求有向无还.
 *      对于图中的每一条有向边 A -> B , 在拓扑排序中A一定在B之前.
 *
 *      1）在图中找到所有入度为0的点输出。
 *      2）把所有入度为0的点在图中删掉，继续找入度为0的点输出，周而复始。
 *      3）图的所有点都被删除后，依次输出的排序就是拓扑排序。
 *      要求：有向图且没有环。
 *      应用：事件安排，编译顺序。
 *
 * 最小生成树: 允许去除图中部分边,要求所有点连在一起,且边权重和最小. 返回所有边的集合.
 * 最小生成树算法之Kruskal：
 *      xxxxxxxxxxxxxxx
 * 最小生成树算法之Prim
 *      1）可以从任意节点出发寻找最小生成树。
 *      2）某个点加入到被选中的点中后，解锁这个点出发的所有新的边。
 *      3）在所有解锁的边中选最小的边，然后看这个边会不会形成环。
 *      4）如果会，不要当前边，继续考察剩下解锁边中最小的边，重复3）
 *      5）如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2）
 *      6）当所有的点都被选取，最小生成树就被得到了。
 *
 * Dijkstra算法
 *      1)Dijkstra算法必须指定一个源点。
 *      2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己的最小距离为0，源点到其它所有点的最小距离都为正无穷大。
 *      3）从距离表中拿出没拿过记录里的最小记录，通过这个点出发的边，更新源点到各个点的最小距离表，不断重复这一步。
 *      4）源点到所有点的记录如果都被拿过一遍，过程停止，最小距离表得到了。
 */
public class T {
}
